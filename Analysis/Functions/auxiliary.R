###############################################
#### Script to collect auxiliary functions ####
###############################################

# Load libraries needed in this script
library(scater)
library(scran)
library(dynamicTreeCut)
library(princurve)
library(dbscan)
library(edgeR)
library(destiny)

#### Split Single cell experiment
split.sce <- function(sce, groups, colData.name = "SubCluster"){
  # List to collect individual single cell experiments
  list.out <- list()
  for(i in groups){
    cur_sce <- sce[,as.character(colData(sce)[[colData.name]]) == as.character(i)]
    cur_sce <- normalize(cur_sce)
    list.out[[i]] <- cur_sce
  }
  names(list.out) <- groups
  list.out
}

#### HVG
# Calculate highly variable genes
# sce: one or multiple single cell experiment objects in form of a list
HVG <- function(sce, numberGenes = 1000){
  # One single cell expereiment object
  if(typeof(sce) == "S4"){
    HVG <- trendVar(sce, use.spikes = FALSE)
    HVG.1 <- decomposeVar(sce, HVG)
    HVG.1 <- HVG.1[order(HVG.1$bio, decreasing = TRUE),]
    rownames(HVG.1)[1:numberGenes]
  }
  # Multiple single cell experiment objects
  else if(typeof(sce) == "list") {
    lapply(sce, function(n){
      HVG <- trendVar(n, use.spikes = FALSE)
      HVG.1 <- decomposeVar(n, HVG)
      HVG.1 <- HVG.1[order(HVG.1$bio, decreasing = TRUE),]
      rownames(HVG.1)[1:numberGenes]
    })
  }
  else{
    print("First argument must either be a single cell experiment object \n
          or a list")
  }
}

#### Clustering
# Perform clustering using dynamic tree cut
DTC <- function(sce, HVG.genes, minClusterSize = 10, deepSplit = 0){
  if(typeof(sce) == "S4"){
    dist.all <- as.dist(sqrt((1 - cor(as.matrix(logcounts(sce)[HVG.genes,]), 
                                      method = "spearman"))/2))
    
    dendro <- hclust(dist.all, method = "ward.D2")
    
    ct <- as.character(cutreeDynamic(dendro = dendro, distM = as.matrix(dist.all), 
                        minClusterSize = minClusterSize, deepSplit = deepSplit))
  }
  else {
    out <- list()
    for(i in 1:length(sce)){
      dist.all <- as.dist(sqrt((1 - cor(as.matrix(logcounts(sce[[i]])[HVG.genes[[i]],]), 
                                        method = "spearman"))/2))
      
      dendro <- hclust(dist.all, method = "ward.D2")
      
      cur_clusters <- paste(names(sce)[i], as.character(cutreeDynamic(dendro = dendro, 
                                                      distM = as.matrix(dist.all), 
                minClusterSize = minClusterSize, deepSplit = deepSplit)), sep = "_")
      names(cur_clusters) <- colData(sce[[i]])$Barcode
      
      out[[names(sce)[i]]] <- cur_clusters
    }
    names(out) <- names(sce)
    out
  }
}

#### Find specifc marker genes
marker.detection <- function(sce, clusters){
  # User scran function findMarkers to perform differential expression
  cur_markers <- findMarkers(sce, clusters)
  
  # Collect group specific markers
  markers.spec <- lapply(cur_markers, function(n){
    if(!is.na(n$Top[1])){
    cur_n <- n[n$FDR < 0.1 & apply(n[,3:ncol(n)], 1, function(x){sum(x > 0)}) == ncol(n) - 2,]
      if(nrow(cur_n) > 0){
        cur_n$GeneName <- rowData(sce)$Symbol[match(rownames(cur_n), rowData(sce)$ID)]
      }
    }
    else{
      cur_n <- NULL
    }
    cur_n
  })
  
}

#### Compute pseudotime with destiny
diffusionPT <- function(sce, HVG, clusters, col_vector,
               exclude = NULL){
  if(!is.null(exclude)){
    dm <- DiffusionMap(t(as.matrix(logcounts(sce)[HVG,!exclude])), k = 20)
    
    plot(dm, col = col_vector[clusters[!exclude]], 
         pch = 16, type = "p")
    
    dpt <- DPT(dm = dm)
    
    dpt$DPT1
  }
  else{
    dm <- DiffusionMap(t(as.matrix(logcounts(sce)[HVG,])), k = 20)
    
    plot(dm, col = col_vector[clusters], 
         pch = 16, type = "p")
    
    dpt <- DPT(dm = dm)
    
    dpt$DPT1
  }
}

#### Compute pseudorank
PT <- function(rd, clusters, col_vector, 
               exclude = NULL, start = NULL, end = NULL){
  if(!is.null(exclude)){
    cur_rd <- rd[!exclude,]
    
    cur_lin <- principal_curve(cur_rd)
    
    plot(cur_rd, col = col_vector[clusters[!exclude]], 
         pch = 16, type = "p")
    lines(cur_lin, lwd = 3)
    
    mat.out <- matrix(data = NA, ncol = ncol(cur_rd) + 1, nrow = length(clusters))
    rownames(mat.out) <- names(clusters)
    colnames(mat.out) <- c(colnames(cur_rd), "rank")
    
    mat.out[!exclude,1:ncol(cur_rd)] <- cur_lin$s
    mat.out[!exclude,"rank"] <- order(cur_lin$tag)
    
    mat.out
  }
  else{
    cur_rd <- rd
    
    cur_lin <- principal_curve(cur_rd)
    
    plot(cur_rd, col = col_vector[clusters], 
         pch = 16, type = "p")
    lines(cur_lin, lwd = 3)
    
    mat.out <- matrix(data = NA, ncol = ncol(cur_rd) + 2, nrow = length(clusters))
    rownames(mat.out) <- names(clusters)
    colnames(mat.out) <- c(colnames(cur_rd), "rank", "lambda")
    
    mat.out[,1:ncol(cur_rd)] <- cur_lin$s
    mat.out[,"rank"] <- order(cur_lin$ord)
    mat.out[,"lambda"] <- cur_lin$lambda
    
    mat.out
  }
}

#### Batch correction
batch.correction <- function(sce, number.HVG = 1000){
  # Calculate highly variable genes and merge
  HVG.genes <- lapply(sce, function(n){
    HVG <- trendVar(n, use.spikes = FALSE)
    decomposeVar(n, HVG)
  })
  
  HVG.df <- do.call("combineVar", HVG.genes)
  HVG.df <- HVG.df[order(HVG.df$bio, decreasing = TRUE),]
  genes <- rownames(HVG.df)[1:number.HVG]
  
  # Batch correction
  func <- paste0("fastMNN(", 
                     paste0("as.matrix(logcounts(sce[[", 1:length(sce), "]])[genes,])", collapse=", "), 
                     ")")
  corrected <- eval( parse(text=func) )
  t(corrected$corrected)
}

batch.correction.old <- function(sce, number.HVG = 1000){
  # Calculate highly variable genes and merge
  HVG.genes <- lapply(sce, function(n){
    HVG <- trendVar(n, use.spikes = FALSE)
    decomposeVar(n, HVG)
  })
  
  HVG.df <- do.call("combineVar", HVG.genes)
  HVG.df <- HVG.df[order(HVG.df$bio, decreasing = TRUE),]
  genes <- rownames(HVG.df)[1:number.HVG]
  
  # Batch correction
  func <- paste0("mnnCorrect(", 
                 paste0("as.matrix(logcounts(sce[[", 1:length(sce), "]])[genes,])", collapse=", "), 
                 ", cos.norm.in=TRUE, cos.norm.out=TRUE, sigma=0.1)")
  corrected <- eval( parse(text=func) )
  do.call("cbind", corrected$corrected)
}

# Differnetial expression testing using edgeR
DE.edgeR <- function(sce, conditions, covariate, lfc){
  # Collect summed counts in matrix
  mat <- matrix(data = NA, 
                ncol = length(unique(paste(covariate, conditions, sep = "_"))), 
                nrow = nrow(sce))
  rownames(mat) <- rownames(counts(sce))
  colnames(mat) <- unique(paste(covariate, conditions, sep = "_"))
  
  for(j in colnames(mat)){
    cur_covariate <- unlist(strsplit(j, "_"))[1]
    cur_condition <- unlist(strsplit(j, "_"))[2]
    mat[,j] <- Matrix::rowSums(counts(sce)[,covariate == cur_covariate &
                                             conditions == cur_condition]) 
  }
  
  # Perform differential testing
  y <- DGEList(counts=mat,
               group=sapply(colnames(mat), 
                            function(n){unlist(strsplit(n, "_"))[1]}))
  y <- calcNormFactors(y)
  
  # Generate design matrix
  design <- model.matrix(~0+sapply(colnames(mat), function(n){unlist(strsplit(n, "_"))[2]}))
  colnames(design) <- substring(colnames(design), regexpr("})", colnames(design)) + 2)
  y <- estimateDisp(y,design)
  
  # Fit the model
  fit <- glmQLFit(y,design, robust = TRUE)
  qlf <- glmTreat(fit,coef=2, lfc = lfc, 
                  contrast = eval(parse(text = paste("makeContrasts(", colnames(design)[1],  " - ", 
                                                     colnames(design)[2], ", levels = design)", sep = ""))))
  cur_markers <- topTags(qlf, n = nrow(qlf$table))$table
  
  # Save markers
  cur_out <- list()
  cur_out[[colnames(design)[2]]] <- cur_markers[cur_markers$logFC < 0 & cur_markers$FDR < 0.1,]
  cur_out[[colnames(design)[2]]]$Genename <- rowData(sce)$Symbol[match(rownames(cur_out[[colnames(design)[2]]]),
                                                                   rowData(sce)$ID)]
  cur_out[[colnames(design)[1]]] <- cur_markers[cur_markers$logFC > 0 & cur_markers$FDR < 0.1,]
  cur_out[[colnames(design)[1]]]$Genename <- rowData(sce)$Symbol[match(rownames(cur_out[[colnames(design)[1]]]),
                                                                   rowData(sce)$ID)]
  
  cur_out
}